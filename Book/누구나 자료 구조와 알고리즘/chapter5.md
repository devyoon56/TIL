# 5장. 빅 오를 사용하거나 사용하지 않는 코드 최적화

빅 오 표기법에서 한 알고리즘이 다른 알고리즘보다 훨씬 빠른 경우에도 두 경쟁 알고리즘을 정확히 똑같은 방식으로 표현하기도 한다.

# 5.1 선택 정렬

선택 정렬(selection sort)이라는 또 다른 정렬 알고리즘에 대해 알아보자.

선택 정렬의 단계

1. 배열의 각 셀을 왼쪽부터 오른쪽으로 확인하면서 어떤 값이 최솟값인지 결정한다.

    - 한 셀씩 이동하면서 가장 작은 값을 기록한다. (실제로는 인덱스를 변수에 저장함)
    - 변수에 저장된 값보다 작은 값이 들어 있는 셀을 만나면 변수가 새 인덱스를 가리키도록 변수의 값을 대체한다.
    - 비교 단계

2. 최솟값이 어느 인덱스에 들어 있는지 알고 있으므로 그 인덱스의 값과 패스스루를 처음 시작했을 때의 값을 교환한다.

    - 첫 패스스루에서 인덱스: 0
    - 두 번째 패스스루에서 인덱스: 1
    - 교환 단계

3. 매 패스스루는 1, 2단계로 이뤄진다. 배열 끝에서 시작하는 패스스루에 도달할 때까지 패스스루를 반복한다.

# 5.2 선택 정렬 실제로 해보기

예제 배열: [4, 2, 7, 1, 3]

### 첫 번째 패스스루

- 인덱스 0의 값을 확인하며 시작한다.
- 현재까지 이 값이 배열의 최솟값이므로(지금까지 확인한 유일한 값이므로) 이 인덱스를 변수에 저장한다.
- 현재까지 최솟값: 인덱스 0에 있는 4

1. 현재 최솟값 4와 2를 비교한다.

    - 2는 4보다 작으므로 2가 최솟값이다.

2. 현재 최솟값 2와 다음 값 7을 비교한다.

    - 2가 여전히 최솟값이다.

3. 현재 최솟값 2와 다음 값 1을 비교한다.

    - 1은 2보다 작으므로 1이 최솟값이다.

4. 현재 최솟값 1과 다음 값 3을 비교한다.

    - 1이 여전히 최솟값이다.
    - 배열의 끝에 도달했으므로 전체 배열의 최솟값이 1로 결정되었다.

5. 최솟값 1과 패스스루를 시작했던 인덱스 0의 값을 교환한다.

    - 교환 결과: [1, 2, 7, 4, 3]
    - 이제 최솟값이 배열 내에 올바른 위치에 있게 되었다.

### 두 번째 패스스루

- 현재 배열: [1, 2, 7, 4, 3]
- 인덱스 0은 이미 정렬됐으므로 두 번째 패스스루는 인덱스 1부터 시작한다.
- 인덱스 1의 값 2가 두 번째 패스스루의 현재 최솟값이다.

6. 현재 최솟값 2와 7을 비교한다.

    - 2가 여전히 최솟값이다.

7. 현재 최솟값 2와 4를 비교한다.

    - 2가 여전히 최솟값이다.

8. 현재 최솟값 2와 3을 비교한다.

    - 2가 여전히 최솟값이다.
    - 이 패스스루의 최솟값이 이미 올바른 위치에 있으므로 교환하지 않는다.

### 세 번째 패스스루

- 현재 배열: [1, 2, 7, 4, 3]
- 인덱스 0, 1은 정렬됐으므로 세 번째 패스스루는 인덱스 2부터 시작한다.
- 인덱스 2의 값 7이 세 번째 패스스루의 현재 최솟값이다.

9. 현재 최솟값 7과 4를 비교한다.

    - 4가 새로운 최솟값이다.

10. 현재 최솟값 4와 3을 비교한다.

    - 3이 새로운 최솟값이다.

11. 최솟값 3과 패스스루를 시작했던 인덱스 2의 값을 교환한다.

    - 교환 결과: [1, 2, 3, 4, 7]
    - 최솟값이 배열 내에 올바른 위치에 있게 되었다.
    - 전체 배열이 정렬됐음을 알지만, 컴퓨터는 아직 알지 못하므로 네 번째 패스스루를 시작해야 한다.

### 네 번째 패스스루

- 현재 배열: [1, 2, 3, 4, 7]
- 인덱스 0, 1, 2는 정렬됐으므로 네 번째 패스스루는 인덱스 3부터 시작한다.
- 인덱스 3의 값 4가 네 번째 패스스루의 현재 최솟값이다.

12. 최솟값 4와 7을 비교한다.

    - 4가 여전히 최솟값이다.
    - 4가 패스스루의 최솟값익 올바른 위치에 있으니 교환하지 않는다.
    - 마지막 셀을 제외한 모든 셀이 올바르게 정렬됐다.
    - 마지막 셀 역시 당연히 올바른 순서이므로 전체 배열이 올바르게 정렬됐다.
    - 정렬된 배열: [1, 2, 3, 4, 7]

## 5.2.1 선택 정렬 구현

자바스크립트로 구현한 선택 정렬

```js
function selectionSort(array) {
  for(let i = 0; i < array.length - 1; i++) {
    let lowestNumberIndex = i;
    for(let j = i + 1; j < array.length; j++) {
      if(array[j] < array[lowerNumberIndex]) {
        lowestNumberIndex = j;
      }
    }

    if(lowestNumberIndex != i) {
      let temp = array[i];
      array[i] = array[lowestNumberIndex];
      array[lowestNumberIndex] = temp;
    }
  }

  return array;
}
```

코드 한 줄씩 살펴보기

```js
for(let i = 0; i < array.length - 1; i++) {
```

- 각 패스스루를 나타내는 루프를 시작한다.
- 변수 i를 사용해 array의 각 값을 가리키며 끝에서 두 번째 값까지 살펴본다.
- 마지막 값을 시작하기 전에 이미 배열이 정렬되므로 마지막 값은 보지 않는다.

```js
let lowestNumberIndex = i;
```

- 현재까지의 최솟값이 들어 있는 인덱스를 저장한다.
- 첫 패스스루 시작 시 0, 두 번째 패스스루 시작 시 1이다.
- 인덱스를 저장하는 이유는 나머지 코드에서 최솟값과 그 인덱스를 사용해야 하기 때문이고 인덱스를 사용하면 둘 다 참조 가능하다.
  - (array[lowestNumberIndex]로 최솟값 확인 가능)

```js
for(let j = i + 1; j < array.length; j++) {
```

- 각 패스스루마다 배열의 나머지 값들을 확인해 현재 최솟값보다 더 작은 값이 있는지 확인한다.

```js
if(array[j] < array[lowerNumberIndex]) {
  lowestNumberIndex = j;
}
```

- 실제로 더 작은 값을 찾으면 이 값의 인덱스를 lowestNumberIndex 변수에 저장한다.
- 내부 루프 종료 시점에 이번 패스스루에서 가장 작은 수의 인덱스가 결정된다.

```js
if(lowestNumberIndex != i) {
  let temp = array[i];
  array[i] = array[lowestNumberIndex];
  array[lowestNumberIndex] = temp;
}
```

- 패스스루의 최솟값이 이미 올바른 위치에 있다면(패스스루의 첫 번째 값이 최솟값인 경우) 아무것도 하지 않는다.
- 최솟값이 올바른 위치에 있지 않다면 교환해야 한다.
- 패스스루를 시작했던 인덱스 i에 있는 값과 최솟값을 교환한다.

```js
return array;
```

- 마지막으로 정렬된 배열을 반환한다.

# 5.3 선택 정렬의 효율성

선택 정렬은 두 종류의 단계를 포함한다.
  - 비교
  - 교환

비교 단계
  - 각 패스스루에서 각 값을 현재까지 찾은 최솟값과 비교

교환 단계
  - 최솟값이 위치해야 하는 인덱스에 있는 값과 최솟값을 교환

배열의 크기가 5인 배열 예제의 경우, 총 10번의 비교가 필요하다.
  - 패스스루 1: 4번
  - 패스스루 2: 3번
  - 패스스루 3: 2번
  - 패스스루 4: 1번

모든 배열 크기에 적용되도록 표현하면 원소 N개에 대해 (N - 1) + (N - 2) + ... 2 + 1번의 비교이다.

교환은 한 패스스루당 최대 1번 일어난다.
  - 각 패스스루마다 최솟값이 이미 올바른 위치에 있느냐에 따라 교환을 안 하거나 교환을 1번만 하기 때문이다.
  - 배열이 역순으로 정렬된 최악의 시나리오에서는 빠짐없이 패스스루마다 교환을 1번 해야 한다.

원소 개수 N개에 대한 버블 정렬과 선택 정렬 비교

|원소 개수(N)|버블 정렬에서 최대 단계 수|선택 정렬에서 최대 단계 수|
|------|---|---|
|5|$5^2=25$|14(10번 비교 + 4번 교환)|
|10|$10^2=100$|54(45번 비교 + 9번 교환)|
|20|$20^2=400$|199(180번 비교 + 19번 교환)|
|40|$40^2=1600$|819(780번 비교 + 39번 교환)|
|80|$80^2=6400$|3239(3160번 비교 + 79번 교환)|

선택 정렬은 버블 정렬보다 단계 수가 절반 정도로 작다. 즉, 선택 정렬이 두 배 더 빠르다.

# 5.4 상수 무시하기

선택 정렬이 버블 정렬보다 빠르지만 빅 오 표기법에서는 선택 정렬과 버블 정렬을 같은 방식으로 설명한다.

선택 정렬에 대략 $N^2$의 반 단계 정도가 필요하므로 선택 정렬의 효율성을 $O(N^2 / 2)$로 설명하면 적당할 듯하다.

|원소 개수(N)|$N^2/2$|선택 정렬에서 최대 단계 수|
|------|---|---|
|5|$5^2/2=12.5$|14|
|10|$10^2/2=50$|54|
|20|$20^2/2=20$|199|
|40|$40^2/2=800$|819|
|80|$80^2/2=3200$|3239|

하지만 실제로 선택 정렬은 빅 오로 표현하면 버블 정렬과 똑같다.

$$
O(N^2)
$$

이것은 빅 오의 규칙 때문이다.

$$
빅\,오\,표기법은\,상수를\,무시한다.
$$

빅 오 표기법은 지수가 아닌 수는 포함하지 않는다. 표현식에서 이러한 수는 그냥 버린다.
  - $N/2$ 단계가 필요한 알고리즘: $O(N)$ 로 표현
  - $N^2 + 10$ 단계가 필요한 알고리즘: 10을 버리고 $O(N^2)$ 로 표현
  - $2N$ 단계가 필요한 알고리즘: 2를 버리고 $O(N)$ 으로 표현

선택 정렬과 버블 정렬에서도 마찬가지다. 두 알고리즘 모두 빅 오로는 같지만 선택 정렬은 버블 정렬보다 두 배나 빠르다.

# 5.5 빅 오 카테고리

빅 오 표기법은 일반적인 카테고리의 알고리즘 속도만 고려한다.

알고리즘의 효율성의 경우, $O(N)$ 알고리즘과 $O(N^2)$ 알고리즘을 비교할 때 두 효율성 간 차이가 너무 커서 $O(N)$이 실제로 $O(2N)$이든 $O(N/2)$이든 심지어 $O(100N)$이든 별로 중요하지 않다.

그래서 $O(N)$과 $O(100N)$은 같은 카테고리로 분류하고, $O(N)$과 $O(N^2)$은 별개의 카테고리로 분류한다.

빅 오 표기법은 단지 알고리즘에 필요한 단계 수만 의미하지 않는다.
  - 데이터가 늘어날 때 알고리즘 단계 수가 장기적으로 어떤 궤적을 그리는지가 중요하다.
  - $O(N)$은 직선 성장을 보여준다. 단계 수가 데이터에 일정 비율로 비례해 직선을 그리며 증가한다.
  - $O(N^2)$은 지수 성장이다.

지수 성장은 어떤 형태의 $O(N)$과도 비교되지 않는 다른 카테고리다.
  - $O(N)$에 어떤 수를 곱하든 데이터가 커지다 보면 결국 $O(N^2)$이 더 느려진다.

따라서 빅 오에서 서로 다른 카테고리에 속하는 두 효율성을 비교할 때 일반적인 카테고리로 분류하는 것으로 충분하다.

하지만 두 알고리즘이 같은 카테고리에 속하더라도 처리 속도가 서로 다를 수 있다.
  - 빅 오에서 서로 다른 카테고리에 속하는 알고리즘을 대조할 때는 빅 오가 완벽하다.
  - 하지만 같은 카테고리에 속한 두 알고리즘이라면 어떤 알고리즘이 더 빠를지를 알기 위해 더 분석해야 한다.

## 5.5.1 실제 예제

```python
def print_numbers_version_one(upperLimit):
  number = 2

  while number <= upperLimit:
    if number % 2 == 0:
      print(number)
    
    number += 1

def print_numbers_version_two(upperLimit):
  number = 2

  while number <= upperLimit:
    print(number)

    number += 2
```

빅 오는 데이터 원소 N개일 때 얼마나 많은 단계 수가 필요한가라는 핵심 질문에 대한 답이다. 위 예제에서 N은 배열의 크기가 아니라 upperLimit으로써 함수에 전달하는 수이다.

첫 번째 버전
  - N단계가 걸린다.
  - upperLimit이 100이면 100단계가 걸린다.
  - 이 알고리즘의 시간 복잡도는 $O(N)$이다.

두 번째 버전
  - N/2단계가 걸린다.
  - upperLimit이 100이면 50단계가 걸린다.
  - 이 알고리즘의 시간 복잡도는 $O(N/2)$이 아니라 $O(N)$이다.

두 번째 버전이 첫 번째 버전보다 두 배 빠르기 때문에 더 나은 방법이다. 빅 오 표기법으로는 똑같이 표현되더라도 어떤 알고리즘이 더 빠른지 알아내려면 분석해야 한다.

## 5.5.2 중요한 단계

이전 예제의 첫 번째 버전은 정말로 N단계가 필요할까?

```python
def print_numbers_version_one(upperLimit):
  number = 2

  while number <= upperLimit:
    if number % 2 == 0:
      print(number)
    
    number += 1
```

나눠서 살펴보면 루프 안에서 여러 단계가 일어난다.

1. number가 2로 나누어 떨어지는지 확인하는 비교 단계다. 비교는 매 루프마다 일어난다.

2. 짝수일 때만 일어나는 출력 단계다. 출력은 한 번 걸러 일어난다.

3. 매 루프마다 실행되는 number += 1이다.

이 예제에서는 어떤 단계를 중요하게 고려해야 할까? 비교나 출력, number 증가 중 무엇이 중요할까?

모든 단계가 중요하다. 빅 오 용어로 단계를 표현할 때 상수를 버리고 표현식을 단순화할 뿐이다.

위 예제에 적용하면
  - N번의 비교, N/2번의 출력, N번의 증가를 모두 합해 2.5N단계다.
  - 상수는 제거되므로 $O(N)$이라 표현한다.
  - 모두 중요한 단계지만 상수를 제거함으로써 루프 안에서 정확히 무슨 일이 일어나는지 보다는 실질적으로 루프가 실행되는 횟수에 더 초점을 맞추게 된다.

# 5.6 마무리

- 빅 오를 사용해 알고리즘이 대체로 얼마나 효율적인지 알 수 있다.
- 빅 오에서 같은 카테고리에 속하는 두 알고리즘을 분석하면 두 알고리즘을 비교할 수 있다.