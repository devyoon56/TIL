# 2장. 알고리즘이 중요한 까닭

어떤 자료 구조를 사용할지 이미 결정했더라도 코드 효율성에 영향을 미치는 중요한 요인이 있다. 이 요인은 알고리즘이다.

알고리즘이란

- 단순히 어떤 과제를 완수하는 명령어 집합이다.

컴퓨터 관점에서 알고리즘은

- 특정 과제를 달성하기 위해 컴퓨터에 제공되는 명령어 집합을 뜻한다.

어떤 코드를 작성하든 컴퓨터가 따르고 실행할 알고리즘을 만드는 것과 같다.

새로운 알고리즘을 분석하기 위한 새로운 자료 구조를 살펴보자.

# 2.1 정렬된 배열

정렬된 배열(ordered array)는 전형적인 배열과 거의 같다. 전형적인 배열과의 유일한 차이점은 

  - 값이 항상 순서대로 있어야 한다는 점이다.
  - 값을 추가할 때마다 적절한 셀에 넣어 배열의 값을 정렬된 상태로 유지한다.

예를 들어 배열 [3, 17, 80, 202]가 있다.

75를 삽입하는 경우, 전형적인 배열이라면 마지막에 75를 삽입한다. 배열의 마지막에 삽입하는 경우 컴퓨터는 한 단계로 삽입을 처리한다.

  - 전형적인 배열의 삽입 결과: [3, 17, 80, 202, 75]

반면 정렬된 배열에서는 값을 오름차순으로 유지하기 위해 적절한 위치에 75를 삽입해야 한다. 하지만 올바른 위치에 75를 삽입하는 작업을 한 단계만에 처리할 수 없다.

  - 75가 들어갈 올바른 위치를 찾고
  - 다른 값들을 옮겨 빈 공간을 만들어야 한다.

정렬된 배열 [3, 17, 80, 202]에 75를 넣는 과정

  - 1단계: 인덱스 0을 확인해서 삽입하려는 값 75가 인덱스 0을 기준으로 왼쪽에 들어갈지, 오른쪽으로 들어갈지 결정한다. (3)
    - 75는 3보다 크므로 오른쪽 어딘가에 삽입해야 한다.
    - 하지만 정확히 어떤 셀에 들어가야 할지 아직 알 수 없다.
    - 다음 셀을 확인해야 한다.
  - 2단계: 다음 셀의 값을 확인한다. (17)
    - 75는 17보다 크므로 다음 셀로 이동해야 한다.
  - 3단계: 다음 셀의 값을 확인한다. (80)
    - 80은 75보다 큰 값이므로 정렬된 배열을 유지하기 위해 80 바로 왼쪽에 75를 삽입해야 한다고 판단할 수 있다.
    - 하지만 75를 넣으려면 데이터를 옮겨야 한다.
  - 4단계: 마지막 값 202를 오른쪽으로 옮긴다.
  - 5단계: 마지막 앞에 있던 값 80을 오른쪽으로 옮긴다.
  - 6단계: 75를 올바른 위치에 삽입한다.

이처럼 정렬된 배열에 삽입하는 경우, 항상 실제 삽입 전에 검색을 먼저 수행해서 삽입할 올바른 위치를 정해야 한다.

위 예제에서 최초에 원소가 4개였고, 삽입에 6단계가 걸렸다. 정렬된 배열의 경우 N개의 원소에 대해 삽입에 총 N+2단계가 걸린다고 할 수 있다.

삽입에 필요한 단계 수는 새 값이 정렬된 배열 어디에 놓이든 비슷하다.

  - 값이 정렬된 배열 앞 쪽에 놓이면 비교가 줄고 이동이 늘어난다.
  - 값이 정렬된 배열 뒤 쪽에 놓이면 비교가 늘고 이동이 줄어든다.

삽입에서 정렬된 배열이 전형적인 배열보다 덜 효율적이지만, 검색 연산에서 정렬된 배열의 강력함이 드러난다.

# 2.2 정렬된 배열의 검색

선형 검색이란

  - 원하는 값을 찾을 때까지 왼쪽에서 오른쪽으로 한 번에 한 셀씩 확인하는 검색 방법

전형적인 배열과 정렬된 배열에서 선형 검색이 어떻게 다른지 보자.

## 전형적인 배열의 선형 검색

일반적인 배열 [17, 3, 75, 202, 80]이 있다. 22라는 값을 찾는 경우, 22가 배열 어디든 존재할 수 있으므로 모든 원소를 하나도 빠짐없이 검색해야 한다. 배열의 끝에 도달하기 전 검색을 멈춘다면 원하는 값을 찾은 경우이다.

## 정렬된 배열의 선형 검색

정렬된 배열에서는 값이 배열에 들어있지 않을 때 검색을 더 빨리 멈출 수 있다. 정렬된 배열 [3, 17, 75, 80, 202]에서 22를 찾는 경우, 75에 도달하면 더 이상 22가 오른쪽에 위치할 수 없으므로 검색을 중단할 수 있다.

루비로 구현한 정렬된 배열의 선형 검색

```ruby
def linear_search(array, search_value)

  # 배열의 모든 원소 순회
  array.each_with_index do |element, index|

    # 원하는 값을 찾으면 그 인덱스를 반환
    if element == search_value
      return index
    
    # 찾고 있던 값보다 큰 원소에 도달하면
    # 루프를 일찍 종료
    elsif element > search_value
      break
    end
  end

  # 배열에서 값을 찾지 못하면 널 반환
  return nil
end
```

linear_search 메서드는 배열의 모든 원소를 순회하며 search_value와 같은 값을 갖는 원소를 찾는다. 순회하던 element가 search_value보다 크면 search_value가 없다는 의미이므로 검색을 중단한다.

선형 검색은 특정 상황에서 전형적인 배열보다 정렬된 배열에서 단계 수가 더 적다. 하지만 찾으려는 값이 배열의 마지막에 있거나 마지막 값보다 크면 마찬가지로 모든 셀을 검색해야 한다.

최악의 시나리오의 경우, 두 배열 유형 모두 원소가 N개이면 선형 검색에 최대 N단계가 필요하다.

하지만 선형 검색은 값을 검색하는 알고리즘 중 하나이다. 정렬된 배열이 전형적인 배열보다 크게 두드러진 장점은 다른 검색 알고리즘을 사용할 수 있다는 점이다.

# 2.3 이진 검색(binary search)

1과 10 사이의 수를 맞춘다고 가정하고 이 과정을 나타내 보자.

- "5"
- 그것보다 크다.
- "8"
- 그것보다 작다.
- "6"
- 그것보다 크다.
- "7"
- 정답

이것이 바로 이진 검색이다.

정렬된 배열에서 이진 검색을 어떻게 수행할까?

원소 9개를 포함하는 정렬된 배열이 있다고 하자. 그리고 정렬된 배열에서 값 7을 찾는다고 하자. 이진 검색은 다음과 같이 동작한다.

  - 1단계: 가운데 셀부터 검색한다.
    - 배열의 길이를 2로 나누어 가운데 셀의 인덱스를 계산할 수 있으므로 가운데 셀에 쉽게 접근 가능하다.
    - 가운데 셀의 값을 확인한다. (9)
    - 값이 9이므로 7은 가운데 셀을 기준으로 왼쪽 어딘가에 있다고 판단할 수 있다.
    - 검색 결과 셀의 절반, 즉 9보다 오른쪽에 있는 모든 셀과 가운데 셀을 검색 대상에서 제거하였다.
  - 2단계: 9보다 왼쪽에 있는 셀들 중 가운데 셀을 확인한다.
    - 가운데 셀이 두 개이므로 임의로 왼쪽 셀을 선택한다.
    - 셀의 값을 확인한다. (4)
    - 찾으려는 값 7은 이 셀의 오른쪽 어딘가에 있어야 한다.
    - 4와 그 왼쪽 셀을 검색 대상에서 제거한다.
  - 3단계: 7일 가능성이 있는 셀이 두 개 남았다. 임의로 왼쪽 셀을 선택하고 확인한다. (6)
  - 4단계: 마지막으로 남은 셀을 확인한다. (7)
    - 이 단계에서 7을 찾지 못하면 정렬된 배열에는 7이 없다는 의미이다.
    - 검색에 성공하였다.

이진 검색은 정렬된 배열에서만 사용할 수 있다. 전형적인 배열은 값의 순서가 뒤죽박죽이므로 주어진 값의 왼쪽에서 찾을지 오른쪽에서 찾을지 절대 알 수 없기 때문이다.

## 2.3.1 코드 구현: 이진 검색

루비로 구현한 이진 검색이다.

```ruby
def binary_search(array, search_value)
  # 찾으려는 값이 있을 수 있는 상한선과 하한선을 결정한다.
  # 최초의 상한선은 배열의 첫 번째 값, 하한선은 마지막 값이다.
  lower_bound = 0
  upper_bound = array.length - 1

  # 상한선과 하한선 사이의 가운데 값을 계속 확인하는 루프를 시작한다.
  while lower_bound <= upper_bound do
    
    # 상한선과 하한선 사이에 중간 지점을 찾는다.
    midpoint = (upper_bound + lower_bound) / 2

    # 중간 지점의 값을 확인한다.
    value_at_midpoint = array[midpoint]

    # 중간 지점의 값이 찾고 있던 값이면 검색을 중단한다.
    # 그렇지 않으면 더 클지 작을지 추측한 바에 따라 상한선이나 하한선을 바꾼다.
    if search_value == value_at_midpoint
      return midpoint
    elsif search_value < value_at_midpoint
      upper_bound = midpoint - 1
    elsif search_value > value_at_midpoint
      lower_bound = midpoint + 1
    end
  end

  # 상한선과 하한선이 같아질 때까지 경곗값을 줄였다면
  # 찾고 있는 값이 배열에 없다는 의미이다.
  return nil
end
```

- 메서드는 가장 먼저 search_value가 있을 수 있는 인덱스 범위를 정한다.
  - 검색 시작 시 search_value가 배열 어디에든 있을 수 있으므로 lower_value를 첫 번재 인덱스로, upper_bound를 마지막 인덱스로 정한다.
- 실제 검색은 while 루프 안에서 수행된다.
  - search_value를 찾을 수 있는 원소가 남아있을 때까지 루프를 수행한다.
  - lower_bound <= upper_bound는 언젠가 범위가 남아 있지 않는 상황에 도달하고 이 상황에서 search_value가 배열에 없다고 판단할 수 있다.
- 루프 내 코드는 범위의 midpoint에 있는 값을 확인한다.
- value_at_point는 범위 내 중간 지점에 있는 항목이다.
  - value_at_point가 search_value와 같다면 검색 성공이므로 search_value를 찾은 인덱스를 반환할 수 있다.
  - search_value가 value_at_point보다 작으면 search_value를 그 앞부분에서만 찾을 수 있다는 의미이다. search_value는 value_at_point보다 뒤에 위치할 수 없으니 upper_bound에 midpoint의 바로 왼쪽 인덱스를 할당해 검색 범위를 좁힌다.
  - search_value가 value_at_midpoint보다 크면 search_value를 midpoint의 오른쪽에서만 위치할 수 있으니 lower_bound를 midpoint의 바로 오른쪽 인덱스를 할당해 검색 범위를 좁힌다.
- 범위가 원소 0개로 좁혀지면 nil을 반환한다.
  - search_value가 배열에 없다는 것을 확신할 수 있다.

# 2.4 이진 검색 대 선형 검색

작은 크기의 정렬된 배열이라면 이진 검색과 선형 검색이 크게 다르지 않다. 하지만 배열이 더 커지면 어떨까?

배열의 크기가 100개라면 각 검색 알고리즘에 필요한 최대 단계 수는 다음과 같다.

  - 선형 검색: 100단계
  - 이진 검색: 7단계

선형 검색은 최악의 시나리오에서 모든 원소를 조사해야 한다. 하지만 이진 검색은 검색 단계마다 검색할 셀 중 절반을 제거할 수 있다.

이진 검색에는 패턴이 존재한다. 정렬된 배열의 크기에 따라 이진 검색의 최대 단계수는 다음과 같다.

  - 배열의 크기: 3, 최대 단계수: 2
  - 배열의 크기: 7, 최대 단계수: 3
  - 배열의 크기: 15, 최대 단계수: 4
  - ...

정렬된 배열의 크기를 두 배씩 늘릴 때마다 이진 검색에 필요한 최대 단계 수가 1씩 증가하는 패턴이 있다. 값을 확인할 때마다 검색할 원소의 절반을 제거하기 때문이다.

선형 검색의 경우 원소 수만큼의 단계가 필요하다. 배열의 크기를 두 배씩 늘릴 때마다 검색에 필요한 단계 수도 두 배로 늘어난다.

선형 검색은 배열에 원소가 많아질수록 그에 비례해 검색에 걸리는 단계 수도 늘어난다. 기본적으로 배열에 원소가 하나 늘어날 때마다 선형 검색에 1단계가 추가된다.

이와 달리 이진 검색은 원소가 많아질수록 단계 수는 아주 조금씩만 늘어난다.

정렬된 배열이 모든 상황에서 빠른 것은 아니다. 장단점이 있다.

  - 정렬된 배열의 삽입은 일반 배열보다 느리다.
  - 정렬된 배열의 검색은 일반 배열보다 훨씬 빠르다. (이진 검색 알고리즘)

애플리케이션에 어떤 구조가 더 좋은지 알려면 항상 이러한 장단점을 파악하고 있어야 한다.

  - 애플리케이션에서 삽입이 자주 일어나는가?
  - 검색이 애플리케이션의 중요한 기능인가?

그리고 이진 검색을 사용하면 정렬된 배열의 삽입도 더 빨라질 수 있다. 정렬된 배열에 삽입하려면 먼저 검색이 필요한데 이때 이진 검색을 사용할 수 있다.

# 2.5 마무리

- 컴퓨팅 목표를 달성하는 방법은 대개 둘 이상이며, 사용자가 선택하는 알고리즘이 코드 속도에 크게 영향을 준다.
- 모든 상황에 완벽하게 맞는 단 하나의 자료 구조나 알고리즘은 거의 없다.
- 알고리즘 간 성능 분석 방법은 필요한 단계 수를 비교하는 것이다.