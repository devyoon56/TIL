# 6장. 긍정적인 시나리오 최적화

최악의 시나리오 외에도 고려할 가치가 있는 상황들이 있다. 모든 시나리오를 고려할 수 있는 능력은 어떤 상황에서든 적절한 알고리즘을 고를 수 있게 해주는 중요한 능력이다.

# 6.1 삽입 정렬

삽입 정렬(insertion sort)을 배우면서 최악의 경우가 아닌 다른 시나리오를 분석하는 것에 어떤 장점이 있는지 알아보자.

삽입 정렬의 순서

1. 첫 번째 패스스루에서 임시로 인덱스 1의 값을 삭제하고 이 값을 임시 변수에 저장한다. 인덱스 1에 값이 없으므로 공백이 생긴다.

    - 이후 각 패스스루마다 다음 인덱스의 값을 삭제한다.

2. 공백 왼쪽에 있는 각 값을 가져와 임시 변수에 있는 값과 비교하는 시프트 단계를 시작한다.

    - 공백 왼쪽에 있는 값이 임시 변수에 있는 값보다 크면 그 값을 오른쪽으로 시프트한다.
    - 값을 오른쪽으로 시프트했으므로 공백이 왼쪽으로 옮겨진다.
    - 임시로 삭제한 값보다 작은 값을 만나거나 배열의 왼쪽 끝에 도달해야 시프트 단계가 끝난다.

3. 임시로 제거한 값을 현재 공백에 삽입한다.

4. 1단계부터 3단계까지가 하나의 패스스루다.

    - 배열의 마지막 인덱스에서 패스스루가 시작할 때까지 패스스루를 반복한다.
    - 이때가 되면 배열은 완전히 정렬된다.

# 6.2 삽입 정렬 실제로 해보기

배열 예제: [4, 2, 7, 1, 3]

### 첫 번째 패스스루

- 인덱스 1의 값을 확인하고 첫 번째 패스스루를 시작한다.
- 인덱스 1의 값은 2

1. 임시로 인덱스 1의 값을 삭제하고 temp_value라는 변수에 저장한다.

2. 인덱스 0의 값 4와 temp_value의 값 2를 비교한다.

3. 4가 2보다 크므로 4를 오른쪽으로 시프트한다.

    - 공백이 배열의 왼쪽 끝에 있으므로 더 이상 왼쪽으로 시프트할 수 없다.

4. temp_value를 다시 배열에 삽입하여 첫 번째 패스스루를 끝낸다.

    - 첫 번째 패스스루 결과: [2, 4, 7, 1, 3]

### 두 번째 패스스루

5. 인덱스 2의 값을 임시로 삭제하고 이 값을 temp_value에 저장한다.

    - temp_value의 값은 7이다.

6. 인덱스 1의 값 4와 temp_value의 값 7을 비교한다.

    - 4가 더 작으므로 시프트하지 않는다.
    - temp_value보다 작은 값이므로 시프트 단계를 끝낸다.

7. temp_value를 다시 공백에 삽입하고 두 번째 패스스루를 끝낸다.

    - 두 번째 패스스루 결과: [2, 4, 7, 1, 3]

### 세 번째 패스스루

8. 인덱스 3의 값을 임시로 삭제하고 이 값을 temp_value에 저장한다.

9. 인덱스 2의 값 7과 temp_value의 값 1을 비교한다.

10. 7이 1보다 크므로 7을 오른쪽으로 시프트한다.

11. 인덱스 1의 값 4와 temp_value의 값 1을 비교한다.

12. 4는 1보다 크므로 마찬가지로 4를 오른쪽으로 시프트한다.

13. 인덱스 0의 값 2와 temp_value의 값 1을 비교한다.

14. 2가 1보다 크므로 2를 오른쪽으로 시프트한다.

15. 공백이 배열 왼쪽 끝에 있으므로 temp_value를 공백에 삽입하고 패스스루를 끝낸다.

    - 세 번째 패스스루 결과: [1, 2, 4, 7, 3]

### 네 번째 패스스루

16. 임시로 인덱스 4의 값 3을 삭제하고 temp_value에 저장한다.

17. 인덱스 3의 값 7과 temp_value의 값 3을 비교한다.

18. 7이 3보다 크므로 7을 오른쪽으로 시프트한다.

19. 인덱스 2의 값 4와 temp_value의 값 3을 비교한다.

20. 4가 3보다 크므로 4를 오른쪽으로 시프트한다.

21. 인덱스 1의 값 2와 temp_value의 값 3을 비교한다.

    - 2는 3보다 작으므로 시프트 단계를 끝낸다.

22. temp_value를 다시 공백에 삽입한다.

    - 배열이 완전히 정렬됐다.
    - 네 번째 패스스루 결과: [1, 2, 3, 4, 7]

## 6.2.1 삽입 정렬 구현

파이썬으로 구현한 삽입 정렬

```python
def insertion_sort(array):
  for index in range(1, len(array)):
    temp_value = array[index]
    position = index - 1

    while position >= 0:
      if array[position] > temp_value:
        array[position + 1] = array[position]
        position = position - 1
      else:
        break

    array[position + 1] = temp_value

  return array
```

코드를 한 단계씩 살펴보자.

```py
for index in range(1, len(array)):
```

- 인덱스 1부터 시작해 전체 배열을 순회하는 루프를 시작한다.
- 매 루프가 하나의 패스스루를 뜻한다.

```py
temp_value = array[index]
```

- 각 패스스루마다 제거한 값을 temp_value라는 변수에 저장한다.

```py
position = index - 1
```

- position 변수를 만들어 temp_value의 바로 왼쪽 인덱스에서 시작한다.
- position은 temp_value와 비교할 각 값을 나타낸다.
- 패스스루를 통과하면서 position은 계속 왼쪽으로 움직이며 각 값을 temp_value와 비교한다.

```py
while position >= 0:
```

- position이 0보다 같거나 큰 동안 실행되는 안쪽 while 루프를 실행시킨다.

```py
if array[position] > temp_value:
```

- 비교를 수행한다.
- position에 있는 값이 temp_value보다 큰지 확인한다.

```py
array[position + 1] = array[position]
```

- position에 있는 값이 temp_value보다 크다면 왼쪽 값을 오른쪽으로 시프트한다.

```py
position = position - 1
```

- 다음 왼쪽 값을 다음 while 루프의 temp_value와 비교할 수 있도록 position 값을 1 감소시킨다.

```py
else:
  break
```

- position에 있는 값이 temp_value보다 작으면 temp_value를 공백에 삽입해야 하니 패스스루를 끝낸다.

```py
array[position + 1] = temp_value
```

- 각 패스스루의 마지막 단계는 temp_value를 공백에 삽입하는 것이다.

```py
return array
```

- 모든 패스스루가 끝나면 정렬된 배열을 반환한다.

# 6.3 삽입 정렬의 효율성

삽입 정렬에 포함된 4종류의 단계

  - 삭제
  - 비교
  - 시프트(이동)
  - 삽입

삽입 정렬의 효율성을 분석하려면 각 단계의 총합을 계산해야 한다.

### 비교

- 비교는 공백 왼쪽에 있는 값과 temp_value를 비교할 때마다 일어난다.
- 배열이 역순으로 정렬된 최악의 시나리오라면 각 패스스루마다 temp_value 왼쪽에 있는 모든 수를 temp_value와 비교해야 한다.
- temp_value 왼쪽에 있는 각 값이 항상 temp_value보다 크기 때문이다.
- 따라서 각 패스스루는 공백이 배열의 왼쪽 끝으로 가야만 끝난다.

첫 번째 패스스루의 경우

  - 인덱스 1의 값이 temp_value인데 temp_value 왼쪽에 값이 하나뿐이므로 최대 1번의 비교가 일어난다.

두 번째 패스스루의 경우

  - 인덱스 2의 값이 temp_value이고 temp_value 왼쪽에 값이 두 개이므로 최대 2번의 비교가 일어난다.

마지막 패스스루의 경우

  - temp_value와 temp_value를 제외한 배열 내 모든 값을 비교해야 한다.
  - 배열에 원소 N개가 있으면 마지막 패스스루에서는 최대 N-1번의 비교가 일어난다.

총 비교 횟수는 다음과 같이 표현할 수 있다.

$$
1+2+3+...+N-1
$$

- 원소가 10개인 배열이면 45번의 비교가 있을 것이다.
- 원소가 20개인 배열이면 190번의 비교가 있을 것이다.

이러한 패턴에 따르면 결국 원소가 N개인 배열일 때 대략 $N^2/2$번의 비교가 일어나는 것으로 보인다.

### 시프트

- 시프트는 값을 한 셀 오른쪽으로 옮길 때마다 일어난다.
- 배열이 역순으로 정렬돼 있다면 비교가 일어날 때마다 값을 오른쪽으로 시프트해야 하므로 비교 횟수만큼 시프트가 일어난다.

최악의 시나리오일 때 비교와 시프트 횟수를 합쳐보자.

- $N^2$ / 비교 2번
- $N^2$ / 시프트 2번
- 합한 결과: $N^2$단계

### 삭제와 삽입

배열에서 temp_value를 삭제하고 다시 삽입하는 작업은 패스스루당 한 번 일어난다.

- 패스스루는 항상 N-1번이므로 결국 N-1번의 삭제와 N-1번의 삽입이 있을 것이다.

### 모든 단계의 총합

- $N^2$번: 비교와 시프트
- $N-1$번: 삭제
- $N-1$번: 삽입
- 총합: $N^2 + 2N - 2$단계

빅 오에는 상수를 무시한다는 규칙이 있으므로 $O(N^2 + N)$으로 단순화할 수 있다.

하지만 빅 오에는 중요한 규칙이 또 있다.

> 다양한 차수가 한데 섞여 있을 때 빅 오 표기법은 가장 높은 차수의 N만 고려한다.

삽입 정렬에 이 규칙을 적용할 수 있다. 이미 $N^2+N$으로 삽입 정렬을 단순화했지만 낮은 차수를 버림으로써 $O(N^2)$로 표현식을 더 단순화한다.

버블 정렬과 선택 정렬 모두 $O(N^2)$이다. 하지만 버블 정렬은 $N^2$단계인데 선택 정렬은 $N^2/2$단계로 선택 정렬이 더 빠르다. 삽입 정렬 역시 $N^2$단계가 걸리므로 언뜻 보기에 버블 정렬만큼 느리다고 할 수 있다.

버블 정렬이나 삽입 정렬보다 두 배 빠른 선택 정렬이 이 셋 중 가장 나은 방법이라고 생각할 수도 있다. 하지만 사실 그렇게 간단하지 않다.

# 6.4 평균적인 경우

최악의 시나리오에서는 선택 정렬이 삽입 정렬보다 빠르다. 하지만 평균 시나리오도 중요하게 고려해야 한다.

왜일까?

- 가장 자주 일어나는 경우가 평균 시나리오다.
- 최선의 그리고 최악의 시나리오는 상대적으로 드물게 발생한다.
- 실제로는 대부분 평균 시나리오가 일어난다.
- 배열이 완벽히 오름차순 또는 내림차순으로 정렬된 경우 보다 값들이 여기저기 흩어져 있는 게 훨씬 더 일어날 법하다.

모든 시나리오 관점에서 삽입 정렬을 검토해 보자.

최악의 시나리오

- 각 패스스루마다 살펴보는 모든 값을 비교하고 시프트한다.
- 비교와 시프트의 합한 결과가 $N^2$번이다.

최선의 시나리오

- 데이터가 이미 오름차순으로 정렬된 최선의 시나리오에서는 각 값이 이미 올바른 위치에 있다.
- 따라서 패스스루당 한 번의 비교만 하며 시프트는 한 번도 일어나지 않는다.

데이터가 임의로 정렬된 경우(평균 시나리오)

- 모든 데이터 혹은 일부 데이터를 비교하고 시프트하거나,
- 어떤 데이터도 비교하거나 시프트하지 않는 패스스루가 있을 것이다.

최악의 시나리오에서는 모든 데이터를 비교하고 시프트하고, 최선의 시나리오에서는 패스스루당 한 번의 비교만 있을 뿐 어떤 데이터도 시프트하지 않는다. 평균 시나리오에서는 대체적으로 데이터의 반을 비교하고 시프트할 것이다.

삽입 정렬이 최악의 시나리오에서 $N^2$단계가 걸린다면 삽입 정렬이 평균 시나리오에서 약 $N^2/2$단계가 걸린다고 볼 수 있다.

### 예제

배열 [1, 2, 3, 4]는 이미 정렬된 최선의 경우다. 같은 데이터에 대해 최악의 경우는 [4, 3, 2, 1]이고, 평균적인 경우라면 [1, 3, 4, 2]와 같은 것이다.

- 최악의 경우([4, 3, 2, 1]): 6번의 비교와 6번의 시프트, 총 12단계
- 평균적인 경우([1, 3, 4, 2]): 4번의 비교와 2번의 시프트, 총 6단계
- 최선의 경우([1, 2, 3, 4]): 3번의 비교와 0번의 시프트, 총 3단계

삽입 정렬의 시나리오 별로 필요한 단계

- 최악의 시나리오: $N^2$ 단계
- 평균 시나리오: $N^2/2$ 단계
- 최선의 시나리오: $N$ 단계

### 선택 정렬과 삽입 정렬의 비교

||최선의 시나리오|평균 시나리오|최악의 시나리오|
|------|---|---|---|
|선택 정렬|$N^2/2$|$N^2/2$|$N^2/2$|
|삽입 정렬|$N$|$N^2/2$|$N^2$|

- 임의로 정렬된 배열 같은 평균적인 경우라면 두 정렬은 유사하게 수행된다.
- 거의 정렬된 데이터를 다룰거라면 삽입 정렬이 더 낫다.
- 대부분 역순으로 정렬된 데이터를 다룰거라면 선택 정렬이 더 낫다.
- 데이터가 어떨지 전혀 알 수 없다면 기본적으로 평균적인 경우이며 둘 다 같다.

# 6.5 실제 예제

두 배열의 교집합을 구하는 자바스크립트 애플리케이션을 작성한다.

```js
function intersection(firstArray, secondArray) {
  let result = [];

  for (let i = 0; i < firstArray.length; i++) {
    for (let j = 0; j < secondArray.length; j++) {
      if (firstArray[i] === secondArray[j]) {
        result.push(firstArray[i]);
      }
    }
  }

  return result;
}
```

- 간단한 중첩 루프를 실행한다.
- 바깥 루프는 첫 번째 배열의 각 값을 순회한다.
- 안쪽 루프는 첫 번째 배열의 각 값을 가리킨 상태에서 두 번째 배열의 각값을 확인하며 첫 번째 배열에서 가리키고 있는 값과 일치하는지 확인한다.

이 알고리즘은 비교와 삽입, 두 종류의 단계를 포함한다. 두 배열 내 모든 값을 서로 비교하면서 값이 일치하면 result 배열에 삽입한다.

비교 횟수

- 두 배열이 크기가 같고, 배열의 크기가 N이면 $N^2$번의 비교를 수행한다.
- 첫 번째 배열의 각 원소에 대해 두 번째 배열의 각 원소를 비교하기 때문이다.
- 이 교집합 알고리즘의 효율성은 $O(N^2)$이다.

삽입 횟수

- 두 배열이 동일할 때 최대 $N$단계가 걸린다.
- $N$은 $N^2$보다 차수가 낮으므로 알고리즘의 효율성은 여전히 $O(N^2)$이다.
- 두 배열의 크기가 다르면, 크기가 각각 N과 M이면, 알고리즘의 효율성은 $O(N * M)$이다.

### 이 알고리즘을 향상시킬 방법

다른 시나리오를 고려해 봐야 하는 시점이다.

두 배열에 공통 값이 있다면 첫 번째 배열의 어떤 값을 꼭 두 번째 배열의 모든 원소와 비교하지 않아도 된다.

```js
function intersection(firstArray, secondArray) {
  let result = [];

  for (let i = 0; i < firstArray.length; i++) {
    for (let j = 0; j < secondArray.length; j++) {
      if (firstArray[i] === secondArray[j]) {
        result.push(firstArray[i]);
        break;
      }
    }
  }

  return result;
}
```

- break를 추가해서 안쪽 루프를 짧게 끝낼 수 있고 단계를 절약할 수 있다.

두 원소가 공통 값을 하나도 포함하지 않는 최악의 시나리오에서는 어쨌든 $N^2$번을 비교해야 한다. 하지만 두 배열이 동일한 최선의 시나리오에서는 N번만 비교하면 된다. 두 배열이 서로 다르지만 일부 값을 공유하는 평균적인 경우에는 성능이 $N$과 $N^2$ 사이쯤일 것이다.

첫 번째 구현에서는 모든 경우에 대해 $N^2$번을 비교하니, 이 방법은 이 알고리즘에 있어 중요한 최적화 방법이다.

# 6.6 마무리

- 최선의, 평균, 최악의 시나리오를 구분하는 능력은 기존 알고리즘을 최적화해서 훨씬 빠르게 만드는 것만큼이나 사용자 요구에 맞는 최적의 알고리즘을 고르는 핵심 기술이다.
- 최악의 경우를 대비하는 것도 좋지만 대부분은 평균적인 경우가 일어난다.