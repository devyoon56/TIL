# 1장. 자료 구조가 중요한 까닭

뛰어난 소프트웨어 개발자가 되려면 더 빠르게 실행되는 코드를 작성하는 능력을 갖추어야 한다.

빠른 코드를 작성하는 첫 번째 단계

- 자료 구조가 무엇인지
- 다양한 자료 구조가 코드 속도에 어떤 영향을 미치는지

를 이해하는 것이다.

# 1.1 자료 구조

자료 구조란 **데이터를 조직하는 방법**이다. 같은 데이터라도 다양한 방식으로 조직할 수 있다.

데이터 조직 방법에 따라 프로그램은 수십 수백 배 더 빠르게 혹은 더 느리게 실행될 수 있다.

다양한 자료 구조를 알고 있으면 애플리케이션을 문제 없이 빠르게 실행 가능한 코드 작성 능력을 갖출 수 있게 된다. 또한 자료 구조가 개발 중인 프로그램의 성능에 어떤 영향을 미칠지 확실히 이해할 수 있다.

# 1.2 배열: 기초 자료 구조

배열은 데이터 원소들의 리스트로, 기초 자료 구조 중 하나다.

배열에만 쓰이는 기술 용어

- 배열의 크기는 배열에 데이터 원소가 얼마나 들어있는지를 나타낸다.
- 배열의 인덱스는 특정 데이터가 배열의 어디에 위치하는지 알려주는 숫자다.
- 대부분의 프로그래밍 언어에서 인덱스는 0부터 시작한다.

## 1.2.1 자료 구조 연산

코드가 자료 구조와 상호작용하는 방법 4가지가 있는데, 대부분의 자료 구조는 4가지 기본 방법을 사용하며, 이를 연산이라 한다.

- 읽기: 자료 구조 내 특정 위치를 찾아보는 것
- 검색: 자료 구조 내에서 특정 값을 찾는 것
- 삽입: 자료 구조에 새로운 값을 추가하는 것
- 삭제: 자료 구조에서 값을 제거하는 것

# 1.3 속도 측정

연산의 속도를 측정할 때는 순수하게 시간 관점에서 연산이 얼마나 빠른지가 아니라 얼마나 많은 단계가 필요한지를 논한다.

코드의 속도를 단계로 측정하는 이유

- 어떤 연산이 정확히 어떤 시간만큼 걸린다고 단정할 수 없음
- 같은 연산이라도 하드웨어에 따라 걸리는 시간은 상이함
- 따라서 시간 기준으로 속도를 측정하면 신뢰할 수 없음

결국, 단계 수 측정이 연산 속도를 분석하는 핵심 비결이다.

# 1.4 읽기

배열 읽기는 배열 내 특정 인덱스에 어떤 값이 들어있는지 찾아보는 것이다.

컴퓨터의 배열 읽기 속도는 한 단계이다. 즉 배열 내 특정 인덱스에 한 번에 접근 가능하다.

메모리의 특징(내부 동작을 단순화했지만 본질을 표현)

- 메모리는 셀로 구성된 거대한 컬렉션
- 프로그램에서 배열을 선언하면 프로그램이 사용할 수 있는  연속된 빈 셀들의 집합이 할당됨
- 메모리 내의 각 셀에는 특정 주소가 존재
- 각 셀의 메모리 주소는 앞 셀의 주소에서 1만큼 증가

컴퓨터가 배열의 특정 인덱스에 한 번에 접근하는 방법은 다음과 같은 특징들이 복합적으로 작용한다.

- 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
- 컴퓨터는 배열을 할당할 때 어떤 메모리 주소에서 시작하는지를 기록한다.
- 그래서 배열의 첫 원소를 요청하면 기록해둔 메모리 주소로 바로 가서 찾는다.

컴퓨터는 배열의 어떤 인덱스에 있는 값이든 간단한 덧셈을 수행해 찾을 수 있다.

어떤 배열의 인덱스 3에 있는 값을 읽는 경우의 과정

  1. 배열의 인덱스는 0부터 시작하고, 컴퓨터는 인덱스 0의 메모리 주소를 읽는다.
  2. 인덱스 3은 인덱스 0부터 정확히 세 슬롯 뒤에 있다.
  3. 인덱스 0의 메모리 주소에 3을 더한 메모리 주소로 간다.

컴퓨터는 어떤 메모리 주소에든 한 번에 접근해 어떤 인덱스든 읽을 수 있어 배열 읽기는 매우 효율적인 연산이다.

# 1.5 검색

배열 검색은 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것이다.

배열 읽기와 비슷해 보이지만 효율성 측면에서 차이가 있다.

- 읽기: 어떤 인덱스든 바로 가서 값을 찾을 수 있어 매우 빠르다.
- 검색: 특정 값으로 바로 갈 수 없으므로 오래 걸린다.

컴퓨터의 중요한 특징 때문이다.

- 모든 메모리 주소에 한 번에 접근할 수 있다.
- 하지만 메모리 주소에 어떤 값이 있는지 바로 알지 못한다.

따라서 배열에서 어떤 값을 찾으려면 각 셀을 한 번에 하나씩 조사하는 방법뿐이다. 특정 값을 찾기 위해 인덱스 0부터 시작해서 특정 값이 있는 인덱스까지 탐색을 진행한다.

만약 특정 값을 발견할 때까지 4개의 셀을 확인하면 연산에는 총 4단계가 걸렸다고 할 수 있다. 이처럼 한 번에 한 셀씩 확인하는 검색을 **선형 검색**이라 한다.

컴퓨터가 배열에서 선형 검색을 수행하는 데 필요한 최대 단계 수는 배열의 크기와 같다. 배열의 크기가 5라면 선형 검색에 필요한 최대 단계수는 5이다.

검색은 읽기보다 비효율적이다.

# 1.6 삽입

배열에 새 데이터를 삽입하는 연산은 배열의 어디에 데이터를 삽입하는 가에 따라 효율성이 다르다.

## 배열의 맨 끝에 데이터를 삽입하는 경우

배열의 맨 끝에 데이터를 삽입하는 경우 삽입에는 딱 한 단계만 필요하다. 이것은 컴퓨터의 또 다른 특징, 배열 할당 시 항상 배열의 크기를 기록한다는 특징 때문이다.

컴퓨터는 배열의 시작 메모리 주소도 기록하므로 배열 크기를 기록한다는 것과 함께 생각해 보면 마지막 항목의 메모리 주소를 계산하는 것은 쉽다.

- 배열의 메모리 시작 주소가 1010이고 크기가 5이면
- 마지막 메모리 주소는 1014이고
- 그 뒤에 데이터를 삽입하면 다음 메모리 주소 1015에 삽입한다는 의미

여기서 문제점은 애초에 배열에 5개의 메모리 셀을 할당했고 6번째 데이터를 추가하려면 이 배열에 셀을 추가로 할당해야 한다는 것이다. (프로그래밍 언어 별로 처리 방식이 상이함)

## 배열의 맨 처음이나 중간에 데이터를 삽입하는 경우

이 경우에는 삽입할 공간을 만들기 위해 데이터들을 이동시켜야 하므로 단계가 늘어난다.

예를 들어 크기가 5인 배열의 인덱스 2에 데이터를 삽입한다면 인덱스 2, 3, 4에 위치한 데이터를 오른쪽으로 옮겨 인덱스 2에 삽입할 데이터를 위한 공간을 만들어야 한다.

하지만 여기에도 추가적인 단계가 필요하다.

1. 인덱스 4의 데이터를 오른쪽으로 옮긴다.
2. 인덱스 3의 데이터를 오른쪽으로 옮긴다.
3. 인덱스 2의 데이터를 오른쪽으로 옮긴다.
4. 인덱스 2에 데이터를 삽입한다.

이와 같이 배열 삽입에서 가장 많은 단계가 필요한 시나리오는 데이터를 배열의 가장 앞에 삽입하는 경우이다. 배열의 가장 앞에 데이터를 삽입하면 배열 내 모든 데이터를 한 셀씩 오른쪽으로 옮겨야 하기 때문이다.

배열의 크기가 N이라면 삽입의 최악의 시나리오에는 N+1 단계가 걸린다. N개의 데이터를 전부 이동시키고 실제 삽입 단계까지 실행하기 때문이다.

# 1.7 삭제

배열의 삭제는 특정 인덱스의 값을 제거하는 것이다.

예를 들어 크기가 5인 배열에서 인덱스 2의 데이터를 삭제한다면 다음과 같은 단계가 필요하다.

1. 인덱스 2의 데이터를 삭제한다.
2. 인덱스 3의 데이터를 왼쪽으로 옮긴다.
3. 인덱스 4의 데이터를 왼쪽으로 옮긴다.

전체 삭제 연산에 3단계가 필요하다. 실제 삭제 단계와 빈 공간을 메꾸는 데이터 이동 단계를 합친 결과이다.

삽입과 비슷하게 배열 삭제에서 가장 많은 단계가 필요한 시나리오는 첫 번째 원소를 삭제하는 것이다. 인덱스 0이 비게 되면 남은 모든 원소들을 왼쪽으로 이동시켜 빈 공간을 채워야 한다.

배열의 크기가 N이라면 삭제의 최악의 시나리오에는 N단계가 걸린다. 배열의 크기가 5라면 1단계는 첫 번째 원소 삭제 단계이고 나머지 단계는 빈 공간을 채우는 데이터 이동 단계이다.

# 1.8 집합: 단 하나의 규칙으로 효율성이 달라진다

집합은 중복 값을 허용하지 않는 자료 구조다.

배열 기반 집합은 배열과 거의 비슷하지만 배열과 유일한 차이점은 **집합은 중복 값의 삽입을 절대로 허용하지 않는다**는 점이다.

즉, 집합은 중복 데이터가 없어야 할 때 유용하다.

- 전화번호부

## 배열 기반 집합의 읽기

집합 읽기는 배열 읽기와 완전히 같다. 컴퓨터는 특정 인덱스의 데이터를 한 단계만에 찾으므로 집합 내 어떤 인덱스든 한 번에 읽을 수 있다.

## 배열 기반 집합의 검색과 삭제

집합 검색은 배열 검색과 차이가 없다. 집합에서 어떤 값을 찾기 위해 최대 N단계가 걸린다.

집합 삭제도 배열 삭제와 차이가 없다. 값을 삭제하는 단계와 데이터를 옮겨 빈 공간을 메우기 위한 단계를 합쳐 최대 N단계가 걸린다.

## 배열 기반 집합의 삽입

집합 삽입은 배열 삽입과 다르다.

### 맨 끝에 데이터 삽입

배열 삽입에서 최선의 시나리오인 맨 끝에 데이터를 삽입하는 경우, 컴퓨터는 1단계만에 값을 끝에 삽입한다.

하지만 집합에서는 먼저 집합에 삽입하려는 데이터가 들어 있는지 결정해야 한다. 중복 데이터를 허용하지 않는 것이 집합이기 때문이다.

삽입하려는 데이터가 집합에 없다는 것을 컴퓨터가 확신하려면 삽입하려는 데이터가 집합에 들어 있는지부터 먼저 검색해야 한다. 따라서 모든 삽입에는 검색이 우선이다.

```python
array = ["apples", "bananas", "cucumbers", "dates", "elderberries"]
```

위 예제의 쇼핑 목록을 집합이라고 가정하자. 이 때 "figs"를 삽입하려면 다음 단계를 거쳐야 한다.

1. 인덱스 0에서 "figs"를 검색한다.
2. 인덱스 1을 검색한다.
3. 인덱스 2를 검색한다.
4. 인덱스 3을 검색한다.
5. 인덱스 4를 검색한다.

집합을 전부 검색한 결과 "figs"를 포함하지 않는다. 이제 삽입해도 된다.

6. 집합의 끝에 "figs"를 삽입한다.

집합의 끝에 삽입하는 게 최선의 시나리오이지만 집합의 크기가 5인 경우 6단계를 수행해야 한다. 최종 삽입 단계를 실행하기 전 모든 원소를 검색해야 한다.

집합의 끝에 삽입하려면 원소 N개에 대해 최대 N+1 단계가 필요하다.

- 집합에 값이 없음을 확인하는데 N단계
- 실제 삽입에 필요한 1단계

이 점은 배열 가장 끝에 삽입하는 것과 다르다.

### 맨 앞에 데이터 삽입

데이터를 집합의 맨 앞에 삽입하는 최악의 시나리오는 다음과 같다.

- 셀 N개를 검색해서 집합이 그 데이터를 포함하지 않음을 확인
- 추가적으로 모든 데이터를 오른쪽으로 옮기는 N단계
- 마지막 단계에 새로운 데이터를 삽입

총 2N+1 단계이다.

# 1.9 마무리

- 자료 구조 성능 측정의 핵심은 필요한 단계 수를 구하는 것이다.

- 자료 구조의 선택이 코드 성능에 영향을 미친다.